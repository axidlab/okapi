// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Api.pbobjc.h"
#import "Security.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(EncryptedMessage);
GPBObjCClassDeclaration(Key);
GPBObjCClassDeclaration(SignedMessage);

#pragma mark - ApiRoot

@implementation ApiRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ApiRoot_FileDescriptor

static GPBFileDescriptor *ApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"didcomm.messaging"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum KeyType

GPBEnumDescriptor *KeyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "X25519\000P256\000Ed25519\000";
    static const int32_t values[] = {
        KeyType_X25519,
        KeyType_P256,
        KeyType_Ed25519,
    };
    static const char *extraTextFormatInfo = "\003\000&\000\001$\000\002\'\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KeyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KeyType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KeyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case KeyType_X25519:
    case KeyType_P256:
    case KeyType_Ed25519:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GenerateKeyRequest

@implementation GenerateKeyRequest

@dynamic seed;
@dynamic keyType;

typedef struct GenerateKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  KeyType keyType;
  NSData *seed;
} GenerateKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seed",
        .dataTypeSpecific.clazz = Nil,
        .number = GenerateKeyRequest_FieldNumber_Seed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateKeyRequest__storage_, seed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = KeyType_EnumDescriptor,
        .number = GenerateKeyRequest_FieldNumber_KeyType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenerateKeyRequest__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateKeyRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateKeyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GenerateKeyRequest_KeyType_RawValue(GenerateKeyRequest *message) {
  GPBDescriptor *descriptor = [GenerateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GenerateKeyRequest_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGenerateKeyRequest_KeyType_RawValue(GenerateKeyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [GenerateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GenerateKeyRequest_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - GenerateKeyResponse

@implementation GenerateKeyResponse

@dynamic hasKey, key;

typedef struct GenerateKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  Key *key;
} GenerateKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = GenerateKeyResponse_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateKeyResponse__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateKeyResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateKeyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConvertKeyRequest

@implementation ConvertKeyRequest

@dynamic hasKey, key;
@dynamic targetType;

typedef struct ConvertKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  KeyType targetType;
  Key *key;
} ConvertKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = ConvertKeyRequest_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConvertKeyRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.enumDescFunc = KeyType_EnumDescriptor,
        .number = ConvertKeyRequest_FieldNumber_TargetType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConvertKeyRequest__storage_, targetType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConvertKeyRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConvertKeyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ConvertKeyRequest_TargetType_RawValue(ConvertKeyRequest *message) {
  GPBDescriptor *descriptor = [ConvertKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ConvertKeyRequest_FieldNumber_TargetType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetConvertKeyRequest_TargetType_RawValue(ConvertKeyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [ConvertKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ConvertKeyRequest_FieldNumber_TargetType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ConvertKeyResponse

@implementation ConvertKeyResponse

@dynamic hasKey, key;

typedef struct ConvertKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  Key *key;
} ConvertKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = ConvertKeyResponse_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConvertKeyResponse__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConvertKeyResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConvertKeyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignRequest

@implementation SignRequest

@dynamic payload;
@dynamic hasKey, key;
@dynamic hasAppendTo, appendTo;

typedef struct SignRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *payload;
  Key *key;
  SignedMessage *appendTo;
} SignRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payload",
        .dataTypeSpecific.clazz = Nil,
        .number = SignRequest_FieldNumber_Payload,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignRequest__storage_, payload),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = SignRequest_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appendTo",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedMessage),
        .number = SignRequest_FieldNumber_AppendTo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignRequest__storage_, appendTo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignResponse

@implementation SignResponse

@dynamic hasMessage, message;

typedef struct SignResponse__storage_ {
  uint32_t _has_storage_[1];
  SignedMessage *message;
} SignResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedMessage),
        .number = SignResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyRequest

@implementation VerifyRequest

@dynamic hasMessage, message;
@dynamic hasKey, key;

typedef struct VerifyRequest__storage_ {
  uint32_t _has_storage_[1];
  SignedMessage *message;
  Key *key;
} VerifyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedMessage),
        .number = VerifyRequest_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = VerifyRequest_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyResponse

@implementation VerifyResponse

@dynamic isValid;

typedef struct VerifyResponse__storage_ {
  uint32_t _has_storage_[1];
} VerifyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isValid",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyResponse_FieldNumber_IsValid,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PackRequest

@implementation PackRequest

@dynamic hasSenderKey, senderKey;
@dynamic hasReceiverKey, receiverKey;
@dynamic associatedData;
@dynamic plaintext;
@dynamic mode;
@dynamic algorithm;

typedef struct PackRequest__storage_ {
  uint32_t _has_storage_[1];
  EncryptionMode mode;
  EncryptionAlgorithm algorithm;
  Key *senderKey;
  Key *receiverKey;
  NSData *associatedData;
  NSData *plaintext;
} PackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderKey",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = PackRequest_FieldNumber_SenderKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PackRequest__storage_, senderKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receiverKey",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = PackRequest_FieldNumber_ReceiverKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PackRequest__storage_, receiverKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "associatedData",
        .dataTypeSpecific.clazz = Nil,
        .number = PackRequest_FieldNumber_AssociatedData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PackRequest__storage_, associatedData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "plaintext",
        .dataTypeSpecific.clazz = Nil,
        .number = PackRequest_FieldNumber_Plaintext,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PackRequest__storage_, plaintext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = EncryptionMode_EnumDescriptor,
        .number = PackRequest_FieldNumber_Mode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PackRequest__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "algorithm",
        .dataTypeSpecific.enumDescFunc = EncryptionAlgorithm_EnumDescriptor,
        .number = PackRequest_FieldNumber_Algorithm,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PackRequest__storage_, algorithm),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PackRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PackRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PackRequest_Mode_RawValue(PackRequest *message) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetPackRequest_Mode_RawValue(PackRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t PackRequest_Algorithm_RawValue(PackRequest *message) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Algorithm];
  return GPBGetMessageRawEnumField(message, field);
}

void SetPackRequest_Algorithm_RawValue(PackRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [PackRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PackRequest_FieldNumber_Algorithm];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PackResponse

@implementation PackResponse

@dynamic hasMessage, message;

typedef struct PackResponse__storage_ {
  uint32_t _has_storage_[1];
  EncryptedMessage *message;
} PackResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(EncryptedMessage),
        .number = PackResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PackResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PackResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PackResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnpackRequest

@implementation UnpackRequest

@dynamic hasSenderKey, senderKey;
@dynamic hasReceiverKey, receiverKey;
@dynamic hasMessage, message;

typedef struct UnpackRequest__storage_ {
  uint32_t _has_storage_[1];
  Key *senderKey;
  Key *receiverKey;
  EncryptedMessage *message;
} UnpackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderKey",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = UnpackRequest_FieldNumber_SenderKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnpackRequest__storage_, senderKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receiverKey",
        .dataTypeSpecific.clazz = GPBObjCClass(Key),
        .number = UnpackRequest_FieldNumber_ReceiverKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnpackRequest__storage_, receiverKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(EncryptedMessage),
        .number = UnpackRequest_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnpackRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnpackRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnpackRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnpackResponse

@implementation UnpackResponse

@dynamic plaintext;

typedef struct UnpackResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *plaintext;
} UnpackResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "plaintext",
        .dataTypeSpecific.clazz = Nil,
        .number = UnpackResponse_FieldNumber_Plaintext,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnpackResponse__storage_, plaintext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnpackResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnpackResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Key

@implementation Key

@dynamic keyId;
@dynamic publicKey;
@dynamic secretKey;
@dynamic keyType;
@dynamic fingerprint;

typedef struct Key__storage_ {
  uint32_t _has_storage_[1];
  KeyType keyType;
  NSString *keyId;
  NSData *publicKey;
  NSData *secretKey;
  NSString *fingerprint;
} Key__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyId",
        .dataTypeSpecific.clazz = Nil,
        .number = Key_FieldNumber_KeyId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Key__storage_, keyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = Key_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Key__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "secretKey",
        .dataTypeSpecific.clazz = Nil,
        .number = Key_FieldNumber_SecretKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Key__storage_, secretKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = KeyType_EnumDescriptor,
        .number = Key_FieldNumber_KeyType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Key__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fingerprint",
        .dataTypeSpecific.clazz = Nil,
        .number = Key_FieldNumber_Fingerprint,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Key__storage_, fingerprint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Key class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Key__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Key_KeyType_RawValue(Key *message) {
  GPBDescriptor *descriptor = [Key descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Key_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetKey_KeyType_RawValue(Key *message, int32_t value) {
  GPBDescriptor *descriptor = [Key descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Key_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
